#version 450

layout(local_size_x = 256) in;

struct Particle {
  vec3 pos;
  float _pad0;
  float radius;
  float opacity;
  vec2 _pad1;
};

layout(std140, set = 0, binding = 0) readonly buffer sbParticles {
  Particle particles[];
};

layout (std430, set = 1, binding = 0) writeonly buffer sbShadows
{
	float shadows[];
};

layout(push_constant) uniform PushConstants {
    vec4 sunDir;
} pushConstants;


bool sphereHit(vec3 ray_origin, vec3 ray_dir, vec3 sphereCentre, float sphereRadius) {
  vec3 offsetRayOrigin = ray_origin - sphereCentre;
  float a = dot(ray_dir, ray_dir);
  float b = 2 * dot(offsetRayOrigin, ray_dir);
  float c = dot(offsetRayOrigin, offsetRayOrigin) - sphereRadius * sphereRadius;
  float discrimintant = b * b - 4 * a * c;

  if (discrimintant >= 0) {
    float dst = (-b - sqrt(discrimintant)) / (2 * a);

    if (dst >= 0) {
      return true;
    }
  }

  return false;
}

void main() {
  const float shadow_multiplier = 35.0;

  vec3 sunDir = normalize(pushConstants.sunDir.xyz);

  uint index = gl_GlobalInvocationID.x;
  if (index > particles.length()) {
    return;
  }

  Particle current = particles[index];
  float shadow = 0.0;

  for(int i = 0; i < particles.length(); i++) {
    if(i == index) {
      continue;
    } 

    Particle other = particles[i];

    vec3 toOther = other.pos - current.pos;

    float dst = length(toOther);

    if(dst > ((other.radius + current.radius) * 0.5) && sphereHit(current.pos, sunDir, other.pos, other.radius)) {
      shadow += shadow_multiplier / float(particles.length()) * current.opacity;
    }
  }

  shadows[index] = 1 - shadow;
}